package main 

// built from twin: {{ .TwinID}}

type langstring struct {
	Value string
	Lang string
}

type Feed struct {
	ID string
	TwinID string
	StoreLast bool
	Values map[string]string
	Tags []string
	Comments []*langstring
	Labels []*langstring
}

type {{ (index .Twin.Result.Labels 0).Value }} struct {

	PUBLIC	string
	ID		string
	Feeds	map[string]*Feed
}

func New{{ (index .Twin.Result.Labels 0).Value }}() {{ (index .Twin.Result.Labels 0).Value }} {
	v := {{ (index .Twin.Result.Labels 0).Value }}{
		PUBLIC: "{{.Twin.Twin.Visibility}}",
		ID: "{{.Twin.Twin.Id.Value}},
		Feeds: make(map[string]Feed),
	}

	{{range .Feeds}}
	f := &Feed{
		ID: "{{.Feed.ID.Value}}",
		TwinID: "{{.Feed.TwinID.Value}}",
		StoreLast: {{.Result.StoreLast}},
		Values: make(map[string]string)
		Tags: make([]string, 0),
		Comments: make([]langstring, 0),
		Labels: make([]langstring, 0),
	}
	{{range .Result.Values}}
	f.Values["{{.Label}}"] = "{{.Comment}}"{{end}}
	{{range .Result.Tags}}
	f.Tags = append(f.Tags, "{{.}}"){{end}}
	{{range .Result.Comments}}
	f.Comments = append(f.Comments, &langstring{Value:"{{.Value}}", Lang:"{{.Lang}}"}){{end}}
	{{range .Result.Labels}}
	f.Labels = append(f.Labels, &langstring{Value:"{{.Value}}", Lang:"{{.Lang}}"}){{end}}
	v.Feeds["{{.Feed.ID.Value}}"] = f{{end}}
	return v
}

func (x *{{ (index .Twin.Result.Labels 0).Value }}) Publish(feedId string, data string) (error){
	feed, ok := x.Feeds[feedId]
	if !ok {
		return errors.New("Publishing to non-existant feed")
	}
	// TODO...
}



