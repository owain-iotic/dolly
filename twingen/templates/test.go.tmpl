package main 

// built from twin: {{ .TwinID}}

type langstring struct {
	Value string
	Lang string
}

type Feed struct {
	ID string
	TwinID string
	StoreLast bool
	Tags []string
	Comments []*langstring
	Labels []*langstring
}

{{range .Feeds}}
type FeedType{{.Feed.ID.Value}} struct {
	Feed
{{range .Result.Values}}
	{{.Label}} string{{end}}
}
{{end}}


type {{ (index .Twin.Result.Labels 0).Value }} struct {

	PUBLIC  string
	ID      string
	{{range .Feeds}}
	Feed{{.Feed.ID.Value}} *FeedType{{.Feed.ID.Value}}
	{{end}}
}

func New{{ (index .Twin.Result.Labels 0).Value }}() {{ (index .Twin.Result.Labels 0).Value }} {
	v := {{ (index .Twin.Result.Labels 0).Value }}{
		PUBLIC: "{{.Twin.Twin.Visibility}}",
		ID: "{{.Twin.Twin.Id.Value}},
	}

	{{range .Feeds}}
	f := &Feed{{.Feed.ID.Value}}{
		ID: "{{.Feed.ID.Value}}",
		TwinID: "{{.Feed.TwinID.Value}}",
		StoreLast: {{.Result.StoreLast}},
		Tags: make([]string, 0),
		Comments: make([]langstring, 0),
		Labels: make([]langstring, 0),
	}
	{{range .Result.Tags}}
	f.Tags = append(f.Tags, "{{.}}"){{end}}
	{{range .Result.Comments}}
	f.Comments = append(f.Comments, &langstring{Value:"{{.Value}}", Lang:"{{.Lang}}"}){{end}}
	{{range .Result.Labels}}
	f.Labels = append(f.Labels, &langstring{Value:"{{.Value}}", Lang:"{{.Lang}}"}){{end}}

	{{range .Result.Values}}
	f.{{.Label}} = "{{.Comment}}"{{end}}
	
	v.Feed{{.Feed.ID.Value}} = f{{end}}
	return v
}

func (x *{{ (index .Twin.Result.Labels 0).Value }}) Publish(feedId string, data string) (error){
	feed, ok := x.Feeds[feedId]
	if !ok {
		return errors.New("Publishing to non-existant feed")
	}
	// TODO...
}

